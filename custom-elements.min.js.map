{"version":3,"sources":["src/custom-elements.js"],"names":["constructor","CustomElementRegistry","_definitions","Map","_constructors","_whenDefinedMap","_observers","Set","_attributeObserver","MutationObserver","_handleAttributeChange","bind","_newInstance","_pendingHtmlImportUrls","enableFlush","_upgradeScheduled","_mainDocumentObserver","_customElements","window","checkValidCustomElementName","name","test","reservedTagList","indexOf","Error","getDefinition","definitions","node","definition","get","is","tagName","toLowerCase","localName","patchElement","varName","origHTMLElement","prototype","newHTMLElement","customElements","i","constructorInfo","_createElement","options","undefined","callConstructor","document","isAttr","element","_nativeCreateElement","call","doc","setAttribute","_upgradeElement","_observeRoot","changeAttribute","value","operation","oldValue","getAttribute","observedAttributes","attributeChangedCallback","newValue","flush","forcePolyfill","define","getCallback","callbackName","callback","TypeError","nameError","has","_extends","extends","extendsNameError","createElement","el","HTMLUnknownElement","connectedCallback","disconnectedCallback","set","_upgradeDoc","deferred","resolve","delete","def","whenDefined","Promise","reject","promise","_resolve","_handleMutations","takeRecords","forEach","observer","onReady","_addNodes","childNodes","_setNewInstance","instance","root","observe","childList","subtree","add","_unobserveRoot","disconnect","mutations","length","mutation","type","removedNodes","addedNodes","_removeNodes","nodeList","visitedNodes","nodeType","Node","ELEMENT_NODE","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","currentNode","_addElement","nextNode","n","DOCUMENT_NODE","parentNode","DOCUMENT_FRAGMENT_NODE","host","shadowRoot","rel","split","_addImport","link","_import","import","importUrl","href","_this","onLoad","removeEventListener","addEventListener","__proto__","console","assert","attributes","attributeOldValue","attributeFilter","hasAttribute","target","attributeName","attributeNamespace","htmlElementSubclasses","index","Number","document.createElement","_nativeCreateElementNS","createElementNS","namespaceURI","qualifiedName","HTMLNS","_nativeAttachShadow","Element","Object","defineProperty","_nativeImportNode","importNode","document.importNode","deep","clone","nodes","_nativeSetAttribute","_nativeRemoveAttribute","removeAttribute","configurable","enumerable"],"mappings":"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","file":"custom-elements.min.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * 2.3\n * http://w3c.github.io/webcomponents/spec/custom/#dfn-element-definition\n * @typedef {{\n *  name: string,\n *  localName: string,\n *  constructor: function(new:HTMLElement),\n *  connectedCallback: (Function|undefined),\n *  disconnectedCallback: (Function|undefined),\n *  attributeChangedCallback: (Function|undefined),\n *  observedAttributes: Array<string>,\n * }}\n */\nlet CustomElementDefinition;\n\n/**\n * @typedef {{\n *  resolve: !function(undefined),\n *  promise: !Promise<undefined>,\n * }}\n */\nlet Deferred;\n\n(function() {\n  'use strict';\n\n  /**\n   * Gets 'customElement' from window so that it could be modified after\n   * the polyfill loads.\n   * @function\n   * @return {CustomElementRegistry}\n   */\n  const _customElements = () => window['customElements'];\n\n  const _observerProp = '__$CE_observer';\n  const _attachedProp = '__$CE_attached';\n  const _upgradedProp = '__$CE_upgraded';\n\n  if (_customElements()) {\n    _customElements().flush = function() {};\n    if (!_customElements().forcePolyfill) {\n      return;\n    }\n  }\n\n  // name validation\n  // https://html.spec.whatwg.org/multipage/scripting.html#valid-custom-element-name\n\n  /**\n   * @const\n   * @type {Array<string>}\n   */\n  const reservedTagList = [\n    'annotation-xml',\n    'color-profile',\n    'font-face',\n    'font-face-src',\n    'font-face-uri',\n    'font-face-format',\n    'font-face-name',\n    'missing-glyph',\n  ];\n\n  /**\n   * @param {!string} name\n   * @return {!Error|undefined}\n   */\n  function checkValidCustomElementName(name) {\n    if (!(/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(name) &&\n        reservedTagList.indexOf(name) === -1)) {\n      return new Error(`The element name '${name}' is not valid.`)\n    }\n  }\n\n  /**\n   * @param {!Node} root\n   * @return {TreeWalker}\n   */\n  function createTreeWalker(root) {\n    // IE 11 requires the third and fourth arguments be present. If the third\n    // arg is null, it applies the default behaviour. However IE also requires\n    // the fourth argument be present even though the other browsers ignore it.\n    return document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   */\n  function isElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n\n  /**\n   * @param {!Element} element\n   * @return {boolean}\n   */\n  function isHtmlImport(element) {\n    return element.tagName === 'LINK' &&\n        element.rel &&\n        element.rel.toLowerCase().split(' ').indexOf('import') !== -1;\n  }\n\n  /**\n   * @param {!Element} element\n   * @return {boolean}\n   */\n  function isConnected(element) {\n    let n = element;\n    do {\n      if (n[_attachedProp] || n.nodeType === Node.DOCUMENT_NODE) return true;\n      n = n.parentNode || n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host;\n    } while(n);\n    return false;\n  }\n\n  /**\n   * A registry of custom element definitions.\n   *\n   * See https://html.spec.whatwg.org/multipage/scripting.html#customelementsregistry\n   *\n   * @property {boolean} enableFlush Set to true to enable the flush() method\n   *   to work. This should only be done for tests, as it causes a memory leak.\n   */\n  class CustomElementRegistry {\n\n    constructor() {\n      /** @private {!Map<string, !CustomElementDefinition>} **/\n      this._definitions = new Map();\n\n      /** @private {!Map<Function, !CustomElementDefinition>} **/\n      this._constructors = new Map();\n\n      /** @private {!Map<string, !Deferred>} **/\n      this._whenDefinedMap = new Map();\n\n      /** @private {!Set<!MutationObserver>} **/\n      this._observers = new Set();\n\n      /** @private {!MutationObserver} **/\n      this._attributeObserver = new MutationObserver(\n        /** @type {function(Array<MutationRecord>, MutationObserver)} */\n        (this._handleAttributeChange.bind(this)));\n\n      /** @private {?HTMLElement} **/\n      this._newInstance = null;\n\n      /** @private {!Set<string>} **/\n      this._pendingHtmlImportUrls = new Set();\n\n      /** @type {boolean} **/\n      this.enableFlush = true;\n\n      /** @private {boolean} **/\n      this._upgradeScheduled = false;\n\n      /** @type {MutationObserver} **/\n      this._mainDocumentObserver = null;\n    }\n\n    // HTML spec part 4.13.4\n    // https://html.spec.whatwg.org/multipage/scripting.html#dom-customelementsregistry-define\n    /**\n     * @param {string} name\n     * @param {function(new:HTMLElement)} constructor\n     * @param {{extends: string}} options\n     * @return {undefined}\n     */\n    define(name, constructor, options) {\n      // 1:\n      if (typeof constructor !== 'function') {\n        throw new TypeError('constructor must be a Constructor');\n      }\n\n      // 2:\n      const nameError = checkValidCustomElementName(name);\n      if (nameError) throw nameError;\n\n      // 3:\n      // Note: we don't track being-defined names and constructors because\n      // define() isn't normally reentrant. The only time user code can run\n      // during define() is when getting callbacks off the prototype, which\n      // would be highly-unusual. We can make define() reentrant-safe if needed.\n      if (this._definitions.has(name)) {\n        throw new Error(`An element with name '${name}' is already defined`);\n      }\n\n      // 4:\n      if (this._constructors.has(constructor)) {\n        throw new Error(`Definition failed for '${name}': ` +\n            `The constructor is already used.`);\n      }\n\n      // 5:\n      /** @type {string} */\n      let localName = name;\n\n      // 6:\n      let _extends = options ? options.extends : null;\n\n      // 7:\n      if (_extends) {\n          // 7.1:\n          const extendsNameError = checkValidCustomElementName(options.extends);\n          if (!extendsNameError) {\n              throw new Error(`Cannot extend '${options.extends}': A custom element cannot extend a custom element.`);\n          }\n\n          // 7.2:\n          const el = document.createElement(options.extends);\n          if (el instanceof window.HTMLUnknownElement) {\n              throw new Error(`Cannot extend '${options.extends}': is not a real HTMLElement`);\n          }\n\n          // 7.3:\n          localName = _extends;\n      }\n\n      // 8, 9: Our define() isn't rentrant-safe\n\n      // 10.1:\n      /** @type {Object} */\n      const prototype = constructor.prototype;\n\n      // 10.2:\n      if (typeof prototype !== 'object') {\n        throw new TypeError(`Definition failed for '${name}': ` +\n            `constructor.prototype must be an object`);\n      }\n\n      /**\n       * @param {string} callbackName\n       * @return {Function|undefined}\n       */\n      function getCallback(callbackName) {\n        const callback = prototype[callbackName];\n        if (callback !== undefined && typeof callback !== 'function') {\n          throw new Error(`${localName} '${callbackName}' is not a Function`);\n        }\n        return callback;\n      }\n\n      // 10.3, 10.4:\n      const connectedCallback = getCallback('connectedCallback');\n\n      const disconnectedCallback = getCallback('disconnectedCallback');\n\n      const attributeChangedCallback = getCallback('attributeChangedCallback');\n\n      // 10.5, 10.6:\n      const observedAttributes =\n          (attributeChangedCallback && constructor['observedAttributes']) || [];\n\n      // 11:\n      /** @type {CustomElementDefinition} */\n      const definition = {\n        name: name,\n        localName: localName,\n        constructor: constructor,\n        connectedCallback: connectedCallback,\n        disconnectedCallback: disconnectedCallback,\n        attributeChangedCallback: attributeChangedCallback,\n        observedAttributes: observedAttributes,\n      };\n\n      // 12:\n      this._definitions.set(name, definition);\n      this._constructors.set(constructor, definition);\n\n      // 13, 14, 15:\n      this._upgradeDoc();\n\n      // 16:\n      /** @type {Deferred} **/\n      const deferred = this._whenDefinedMap.get(localName);\n      if (deferred) {\n        deferred.resolve(undefined);\n        this._whenDefinedMap.delete(localName);\n      }\n    }\n\n    /**\n     * Returns the constructor defined for `name`, or `null`.\n     *\n     * @param {string} name\n     * @return {Function|undefined}\n     */\n    get(name) {\n      // https://html.spec.whatwg.org/multipage/scripting.html#custom-elements-api\n      const def = this._definitions.get(name);\n      return def ? def.constructor : undefined;\n    }\n\n    /**\n     * Returns a `Promise` that resolves when a custom element for `name` has\n     * been defined.\n     *\n     * @param {string} name\n     * @return {!Promise}\n     */\n    whenDefined(name) {\n      // https://html.spec.whatwg.org/multipage/scripting.html#dom-customelementsregistry-whendefined\n      const nameError = checkValidCustomElementName(name);\n      if (nameError) return Promise.reject(nameError);\n      if (this._definitions.has(name)) return Promise.resolve();\n\n      /** @type {Deferred} **/\n      let deferred = this._whenDefinedMap.get(name);\n      if (deferred) return deferred.promise;\n\n      let resolve;\n      const promise = new Promise(function(_resolve, _) {\n       resolve = _resolve;\n      });\n      deferred = {promise, resolve};\n      this._whenDefinedMap.set(name, deferred);\n      return promise;\n    }\n\n    /**\n     * Causes all pending mutation records to be processed, and thus all\n     * customization, upgrades and custom element reactions to be called.\n     * `enableFlush` must be true for this to work. Only use during tests!\n     */\n    flush() {\n      if (this.enableFlush) {\n        // console.warn(\"flush!!!\");\n        this._handleMutations(this._mainDocumentObserver.takeRecords());\n        this._handleAttributeChange(this._attributeObserver.takeRecords());\n        this._observers.forEach(\n          /**\n           * @param {!MutationObserver} observer\n           * @this {CustomElementRegistry}\n           */\n          function(observer) {\n            this._handleMutations(observer.takeRecords());\n          }, this);\n      }\n    }\n\n    /**\n     * Upgrade all existing in document elements. This process is expensive so\n     * is optionally batched based on the state of HTMLImports. (Note,\n     * this batching might not be necessary if instead of walking the dom,\n     * a map of upgrade candidates was maintained.)\n     * @private\n     */\n    _upgradeDoc() {\n      if (!this._upgradeScheduled) {\n        this._upgradeScheduled = true;\n        const onReady = () => {\n          this._upgradeScheduled = false;\n          if (!this._mainDocumentObserver) {\n            this._mainDocumentObserver = this._observeRoot(document);\n          }\n          this._addNodes(document.childNodes);\n\n        };\n        if (window['HTMLImports']) {\n          window['HTMLImports']['whenReady'](onReady);\n        } else {\n          onReady();\n        }\n      }\n    }\n\n    /**\n     * @param {?HTMLElement} instance\n     * @private\n     */\n    _setNewInstance(instance) {\n      this._newInstance = instance;\n    }\n\n    /**\n     * Observes a DOM root for mutations that trigger upgrades and reactions.\n     * @param {Node} root\n     * @private\n     */\n    _observeRoot(root) {\n      //console.log('_observeRoot', root, root.baseURI);\n      // console.assert(!root[_observerProp]);\n      if (root[_observerProp] != null) {\n        //console.warn(`Root ${root} is already observed`);\n        return root[_observerProp];\n      }\n      root[_observerProp] = new MutationObserver(\n        /** @type {function(Array<MutationRecord>, MutationObserver)} */\n        (this._handleMutations.bind(this)));\n      root[_observerProp].observe(root, {childList: true, subtree: true});\n      if (this.enableFlush) {\n        // this is memory leak, only use in tests\n        this._observers.add(root[_observerProp]);\n      }\n      return root[_observerProp];\n    }\n\n    /**\n     * @param {Node} root\n     * @private\n     */\n    _unobserveRoot(root) {\n      if (root[_observerProp] != null) {\n        root[_observerProp].disconnect();\n        if (this.enableFlush) {\n          this._observers.delete(root[_observerProp]);\n        }\n        root[_observerProp] = null;\n      }\n    }\n\n    /**\n     * @param {!Array<!MutationRecord>} mutations\n     * @private\n     */\n    _handleMutations(mutations) {\n      for (let i = 0; i < mutations.length; i++) {\n        /** @type {!MutationRecord} */\n        const mutation = mutations[i];\n        if (mutation.type === 'childList') {\n          // Note: we can't get an ordering between additions and removals, and\n          // so might diverge from spec reaction ordering\n          const addedNodes = /** @type {!NodeList<!Node>} */(mutation.addedNodes);\n          const removedNodes = /** @type {!NodeList<!Node>} */(mutation.removedNodes);\n          this._addNodes(addedNodes);\n          this._removeNodes(removedNodes);\n        }\n      }\n    }\n\n    /**\n     * @param {!(NodeList<!Node>|Array<!Node>)} nodeList\n     * @param {?Set<Node>=} visitedNodes\n     * @private\n     */\n    _addNodes(nodeList, visitedNodes) {\n      visitedNodes = visitedNodes || new Set();\n\n      for (let i = 0; i < nodeList.length; i++) {\n        const root = nodeList[i];\n\n        if (!isElement(root)) {\n          continue;\n        }\n\n        // Since we're adding this node to an observed tree, we can unobserve\n        this._unobserveRoot(root);\n\n        const walker = createTreeWalker(root);\n        do {\n          const node = /** @type {!HTMLElement} */ (walker.currentNode);\n          if (node.getAttribute('is')) {\n            node.is = node.getAttribute('is');\n          }\n          this._addElement(node, visitedNodes);\n        } while (walker.nextNode())\n      }\n    }\n\n    /**\n     * @param {!HTMLElement} element\n     * @param {!Set<Node>=} visitedNodes\n     */\n    _addElement(element, visitedNodes) {\n      if (visitedNodes.has(element)) return;\n      visitedNodes.add(element);\n\n      /** @type {?CustomElementDefinition} */\n      const definition = getDefinition(this._definitions, element);\n      if (definition) {\n        if (!element[_upgradedProp]) {\n          this._upgradeElement(element, definition, true);\n        }\n        if (element[_upgradedProp] && !element[_attachedProp] && isConnected(element)) {\n          element[_attachedProp] = true;\n          if (definition.connectedCallback) {\n            definition.connectedCallback.call(element);\n          }\n        }\n      }\n      if (element.shadowRoot) {\n        // TODO(justinfagnani): do we need to check that the shadowRoot\n        // is observed?\n        this._addNodes(element.shadowRoot.childNodes, visitedNodes);\n      }\n      if (isHtmlImport(element)) {\n        this._addImport(/** @type {!HTMLLinkElement} */(element), visitedNodes);\n      }\n    }\n\n    /**\n     * @param {!HTMLLinkElement} link\n     * @param {!Set<Node>=} visitedNodes\n     */\n    _addImport(link, visitedNodes) {\n      // During a tree walk to add or upgrade nodes, we may encounter multiple\n      // HTML imports that reference the same document, and may encounter\n      // imports in various states of loading.\n\n      // First, we only want to process the first import for a document in a\n      // walk, so we check visitedNodes for the document, not the link.\n      //\n      // Second, for documents that haven't loaded yet, we only want to add one\n      // listener, regardless of the number of links or walks, so we track\n      // pending loads in _pendingHtmlImportUrls.\n\n      // Check to see if the import is loaded\n      /** @type {?Document} */\n      const _import = link.import;\n      if (_import) {\n        // The import is loaded, but only process the first link element\n        if (visitedNodes.has(_import)) return;\n        visitedNodes.add(_import);\n\n        // The import is loaded observe it\n        if (!_import[_observerProp]) this._observeRoot(_import);\n\n        // walk the document\n        this._addNodes(_import.childNodes, visitedNodes);\n      } else {\n        // The import is not loaded, so wait for it\n        /** @type {string} */\n        const importUrl = link.href;\n        if (this._pendingHtmlImportUrls.has(importUrl)) return;\n        this._pendingHtmlImportUrls.add(importUrl);\n\n        /**\n         * @const\n         * @type {CustomElementRegistry}\n         */\n        const _this = this;\n        const onLoad = function() {\n          link.removeEventListener('load', /** @type {function(Event)} */(onLoad));\n          if (!link.import[_observerProp]) _this._observeRoot(link.import);\n          // We don't pass visitedNodes because this is async and not part of\n          // the current tree walk.\n          _this._addNodes(link.import.childNodes);\n        };\n        link.addEventListener('load', onLoad);\n      }\n    }\n\n    /**\n     * @param {NodeList} nodeList\n     * @private\n     */\n    _removeNodes(nodeList) {\n      for (let i = 0; i < nodeList.length; i++) {\n        const root = nodeList[i];\n\n        if (!isElement(root)) {\n          continue;\n        }\n\n        // Since we're detatching this element from an observed root, we need to\n        // reobserve it.\n        // TODO(justinfagnani): can we do this in a microtask so we don't thrash\n        // on creating and destroying MutationObservers on batch DOM mutations?\n        this._observeRoot(root);\n\n        const walker = createTreeWalker(root);\n        do {\n          const node = walker.currentNode;\n          if (node[_upgradedProp] && node[_attachedProp]) {\n            node[_attachedProp] = false;\n            const definition = getDefinition(this._definitions, node);\n            if (definition && definition.disconnectedCallback) {\n              definition.disconnectedCallback.call(node);\n            }\n          }\n        } while (walker.nextNode())\n      }\n    }\n\n    /**\n     * Upgrades or customizes a custom element.\n     *\n     * @param {HTMLElement} element\n     * @param {CustomElementDefinition} definition\n     * @param {boolean} callConstructor\n     * @private\n     */\n    _upgradeElement(element, definition, callConstructor) {\n      const prototype = definition.constructor.prototype;\n      element.__proto__ = prototype;\n      if (callConstructor) {\n        this._setNewInstance(element);\n        new (definition.constructor)();\n        element[_upgradedProp] = true;\n        console.assert(this._newInstance == null);\n      }\n\n      const observedAttributes = definition.observedAttributes;\n      const attributeChangedCallback = definition.attributeChangedCallback;\n      if (attributeChangedCallback && observedAttributes.length > 0) {\n        this._attributeObserver.observe(element, {\n          attributes: true,\n          attributeOldValue: true,\n          attributeFilter: observedAttributes,\n        });\n\n        // Trigger attributeChangedCallback for existing attributes.\n        // https://html.spec.whatwg.org/multipage/scripting.html#upgrades\n        for (let i = 0; i < observedAttributes.length; i++) {\n          const name = observedAttributes[i];\n          if (element.hasAttribute(name)) {\n            const value = element.getAttribute(name);\n            attributeChangedCallback.call(element, name, null, value, null);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {!Array<!MutationRecord>} mutations\n     * @private\n     */\n    _handleAttributeChange(mutations) {\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        if (mutation.type === 'attributes') {\n          const target = /** @type {HTMLElement} */(mutation.target);\n          // We should be gaurenteed to have a definition because this mutation\n          // observer is only observing custom elements observedAttributes\n          const definition = getDefinition(this._definitions, target);\n          const name = /** @type {!string} */(mutation.attributeName);\n          const oldValue = mutation.oldValue;\n          const newValue = target.getAttribute(name);\n          // Skip changes that were handled synchronously by setAttribute\n          if (newValue !== oldValue) {\n            const namespace = mutation.attributeNamespace;\n            definition.attributeChangedCallback.call(target, name, oldValue, newValue, namespace);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {!Map<string, !CustomElementDefinition>} definitions\n   * @param {!Node|!HTMLElement|null} node\n   */\n  function getDefinition(definitions, node) {\n    const name = typeof node.is === 'string' ? node.is : node.tagName.toLowerCase();\n    const definition = definitions.get(name);\n    if (definition) {\n      // Make sure local name matches the actual node's tagName\n      return definition.localName === node.tagName.toLowerCase() || definition.localName === node.is ? definition : null;\n    } else {\n      return null;\n    }\n  }\n\n  // Closure Compiler Exports\n  window['CustomElementRegistry'] = CustomElementRegistry;\n  CustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;\n  CustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;\n  CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;\n  CustomElementRegistry.prototype['flush'] = CustomElementRegistry.prototype.flush;\n  CustomElementRegistry.prototype['polyfilled'] = true;\n  // TODO(justinfagnani): remove these in production code\n  CustomElementRegistry.prototype['_observeRoot'] = CustomElementRegistry.prototype._observeRoot;\n  CustomElementRegistry.prototype['_addImport'] = CustomElementRegistry.prototype._addImport;\n\n  patchElement('HTMLElement')\n  var htmlElementSubclasses = [ 'Button', 'Canvas', 'Data', 'Head', 'Mod', 'TableCell', 'TableCol', 'Anchor', 'Area', 'Base', 'Body', 'BR', 'DataList', 'Details', 'Dialog', 'Div', 'DList', 'Embed', 'FieldSet', 'Form', 'Heading', 'HR', 'Html', 'IFrame', 'Image', 'Input', 'Keygen', 'Label', 'Legend', 'LI', 'Link', 'Map', 'Media', 'Menu', 'MenuItem', 'Meta', 'Meter', 'Object', 'OList', 'OptGroup', 'Option', 'Output', 'Paragraph', 'Param', 'Picture', 'Pre', 'Progress', 'Quote', 'Script', 'Select', 'Slot', 'Source', 'Span', 'Style', 'TableCaption', 'Table', 'TableRow', 'TableSection', 'Template', 'TextArea', 'Time', 'Title', 'Track', 'UList', 'Unknown'];\n  for (let index in htmlElementSubclasses) {\n      patchElement(`HTML${htmlElementSubclasses[Number(index)]}Element`);\n  }\n\n  function patchElement(varName) {\n      /** @const */\n      const origHTMLElement = window[varName];\n      if (!origHTMLElement) {\n          return;\n      }\n      CustomElementRegistry.prototype[`native${varName}`] = origHTMLElement;\n      /**\n       * @type {function(new: HTMLElement)}\n       */\n      const newHTMLElement = function() {\n        const customElements = _customElements();\n\n        // If there's an being upgraded, return that\n        if (customElements._newInstance) {\n          const i = customElements._newInstance;\n          customElements._newInstance = null;\n          return i;\n        }\n        if (this.constructor) {\n          // Find the tagname of the constructor and create a new element with it\n          const constructorInfo = customElements._constructors.get(this.constructor);\n          const options = constructorInfo.name !== constructorInfo.localName ? {is: constructorInfo.name} : undefined;\n          return _createElement(document, constructorInfo.localName, options, false);\n        }\n        throw new Error('Unknown constructor. Did you call customElements.define()?');\n      }\n      window[varName] = newHTMLElement;\n      window[varName].prototype = origHTMLElement.prototype;\n  }\n\n  // patch doc.createElement\n  // TODO(justinfagnani): why is the cast neccessary?\n  // Can we fix the Closure DOM externs?\n  const _nativeCreateElement =\n    /** @type {function(this:Document, string, (Object|undefined)=): !HTMLElement}}*/\n    (document.createElement);\n\n  /**\n   * Creates a new element and upgrades it if it's a custom element.\n   * @param {!Document} doc\n   * @param {!string} tagName\n   * @param {Object|undefined} options\n   * @param {boolean} callConstructor whether or not to call the elements\n   *   constructor after upgrading. If an element is created by calling its\n   *   constructor, then `callConstructor` should be false to prevent double\n   *   initialization.\n   */\n  function _createElement(doc, tagName, options, callConstructor) {\n    const customElements = _customElements();\n    let isAttr;\n    if (options && options.is) {\n        // We're going to take care of setting the is attribute ourselves\n        isAttr = options.is;\n        delete options.is;\n    }\n    const element = options ? _nativeCreateElement.call(doc, tagName, options) :\n      _nativeCreateElement.call(doc, tagName);\n    if (isAttr) {\n        element.setAttribute('is', isAttr);\n        element.is = isAttr;\n    }\n    const definition = getDefinition(customElements._definitions, element);\n    if (definition) {\n      customElements._upgradeElement(element, definition, callConstructor);\n    }\n    customElements._observeRoot(element);\n    return element;\n  };\n  document.createElement = function(tagName, options) {\n    return _createElement(document, tagName, options, true);\n  }\n\n  // patch document.createElementNS\n\n  const HTMLNS = 'http://www.w3.org/1999/xhtml';\n\n  /** @type {function(this:Document,string,string):Element} */\n  const _nativeCreateElementNS = document.createElementNS;\n  document.createElementNS =\n    /** @type {function(this:Document,(string|null),string):!Element} */\n    (function(namespaceURI, qualifiedName) {\n      if (namespaceURI === HTMLNS) {\n        return document.createElement(qualifiedName);\n      } else {\n        return _nativeCreateElementNS.call(document, namespaceURI, qualifiedName);\n      }\n    });\n\n  // patch Element.attachShadow\n\n  /** @type {function({closed: boolean})} */\n  const _nativeAttachShadow = Element.prototype['attachShadow'];\n  if (_nativeAttachShadow) {\n    Object.defineProperty(Element.prototype, 'attachShadow', {\n      value: function(options) {\n        /** @type {!Node} */\n        const root = _nativeAttachShadow.call(this, options);\n        /** @type {CustomElementRegistry} */\n        const customElements = _customElements();\n        customElements._observeRoot(root);\n        return root;\n      },\n    });\n  }\n\n  // patch document.importNode\n\n  const _nativeImportNode = document.importNode;\n  document.importNode = function(node, deep) {\n    const clone = /** @type{!Node} */(_nativeImportNode.call(document, node, deep));\n    const customElements = _customElements();\n    const nodes = isElement(clone) ? [clone] : clone.childNodes;\n    /** @type {CustomElementRegistry} */(_customElements())._addNodes(nodes);\n    return clone;\n  };\n\n  // patch Element.setAttribute & removeAttribute\n\n  const _nativeSetAttribute = Element.prototype.setAttribute;\n  Element.prototype['setAttribute'] = function(name, value) {\n    changeAttribute(this, name, value, _nativeSetAttribute);\n  };\n  const _nativeRemoveAttribute = Element.prototype.removeAttribute;\n  Element.prototype['removeAttribute'] = function(name) {\n    changeAttribute(this, name, null, _nativeRemoveAttribute);\n  };\n\n  function changeAttribute(element, name, value, operation) {\n    name = name.toLowerCase();\n    const oldValue = element.getAttribute(name);\n    operation.call(element, name, value);\n\n    // Bail if this wasn't a fully upgraded custom element\n    if (element[_upgradedProp] == true) {\n      const definition = getDefinition(_customElements()._definitions, element);\n      const observedAttributes = definition.observedAttributes;\n      const attributeChangedCallback = definition.attributeChangedCallback;\n      if (attributeChangedCallback && observedAttributes.indexOf(name) >= 0) {\n        const newValue = element.getAttribute(name);\n        if (newValue !== oldValue) {\n          attributeChangedCallback.call(element, name, oldValue, newValue, null);\n        }\n      }\n    }\n  }\n\n  Object.defineProperty(window, 'customElements', {\n    value: new CustomElementRegistry(),\n    configurable: true,\n    enumerable: true,\n  });\n\n  // TODO(justinfagnani): Remove. Temporary for backward-compatibility\n  window['CustomElements'] = {\n    takeRecords() {\n      if (_customElements().flush) _customElements().flush();\n    }\n  }\n})();\n"]}